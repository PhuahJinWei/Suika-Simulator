<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>スイケ Suike</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <style>
    :root {
      --bg: #0f1220; --panel: #171a2b; --accent: #66d9ef; --text: #e9ecf1; --muted: #99a2b2;
      --danger: #ff6b6b; --ok: #9be564; --board-bg: #1b2144; --board-wall: #12162e; --aim: #66d9ef88;
    }
    :root[data-theme="light"] {
      --bg: #f2f5fb; --panel: #ffffff; --accent: #0b74ff; --text: #1d2330; --muted: #6a7280;
      --danger: #d44b4b; --ok: #4caf50; --board-bg: #f4f7ff; --board-wall: #d9dff0; --aim: #0b74ff66;
    }

    * { box-sizing: border-box; }
    html, body { width:100%; height:100dvh; margin:0; overflow:hidden; overscroll-behavior:none; touch-action:pan-x pan-y; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 800px at 70% -10%, #1a1f39 0%, var(--bg) 55%);
      color: var(--text); display:grid; place-items:center;
    }
    body.light-bg { background: radial-gradient(1200px 800px at 70% -10%, #dfe6ff 0%, var(--bg) 55%); }

    .wrap {
      display:grid; grid-template-columns:auto; gap:12px; padding:10px;
      width:min(1100px,100vw); max-height:calc(100dvh - 20px); align-items:start; transform-origin:top center;
    }
    .panel {
      background:var(--panel); border:1px solid #24284233; border-radius:14px; padding:10px;
      box-shadow:0 10px 30px rgba(0,0,0,.15), inset 0 1px 0 rgba(255,255,255,.03);
    }
    .hud { 
      display:grid; gap:10px; position:static; margin:0 auto; 
      width: min(92vw, 520px);
    }
    .row { display:flex; gap:10px; align-items:center; justify-content:space-between; }

    .stat {
      background: color-mix(in oklab, var(--panel), #000 10%);
      border:1px solid #2a305733; border-radius:12px; padding:8px 10px; text-align:center;
    }
    .stat h3 { margin:0; font-size:12px; color:var(--muted); font-weight:600; letter-spacing:.05em; text-transform:uppercase; }
    .stat p { margin:6px 0 0; font-size:18px; font-weight:700; }

    .next { display:grid; justify-items:center; gap:6px; }
    .next-title { font-weight:700; }
    .fruit-preview { border-radius:50%; display:block; border:2px solid #00000014; box-shadow: inset 0 6px 10px #0004, 0 6px 14px #0002; background:transparent; }
    .nextCanvasBox { width: clamp(96px, 28vw, 160px); }
    #nextCanvas { width:100%; height:auto; display:block; }

    .toolbar .row { justify-content:stretch; }
    button {
      appearance:none; border:1px solid #2a305733; color:var(--text);
      background:linear-gradient(color-mix(in oklab, var(--panel), #000 6%), color-mix(in oklab, var(--panel), #000 12%));
      padding:8px 12px; border-radius:10px; font-weight:700; cursor:pointer;
      box-shadow:0 6px 14px rgba(0,0,0,.18), inset 0 1px 0 rgba(255,255,255,.05); line-height:1;
    }
    button:hover { filter:brightness(1.05); }
    button:active { transform:translateY(1px); }
    #toggleThemeMain { width:100%; font-size:130%; touch-action: manipulation; }
    #restart { width:100%; font-size:130%; touch-action: manipulation; }
    .hint { color:var(--muted); font-size:12px; line-height:1.35; text-align:center; }

    .score-next { display:grid; grid-template-columns:1fr auto; gap:12px; align-items:center; }
    .scores { display:grid; gap:10px; }

    #game {
      display:block; margin: 0 auto;
      background:linear-gradient(#0d0f1b, #0a0c16); border-radius:14px; border:1px solid #24284233;
      box-shadow:0 12px 40px rgba(0,0,0,.25), inset 0 1px rgba(255,255,255,.03);
      width:100%; height:auto; user-select:none; -webkit-user-select:none;
      touch-action:none;
      max-width: 100%;
    }

    @media (min-width: 981px) {
      .wrap { grid-template-columns:max-content 360px; justify-content:center; }
      .panel:has(#game) { width:max-content; padding:12px; }
      #game { 
        width: auto;
        height: auto;
        max-height: 800px;      /* keep game within 800px height on laptop/desktop */
        max-width: 640px;       /* don't let it grow too wide */
      }
      .nextCanvasBox { width:140px; }
      .hud { width:360px !important; }
    }

    /* Overlays */
    .overlay {
      position:absolute; inset:0;
      display:none; place-items:center;
      pointer-events:none;
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(1px);
      border-radius: 14px;
    }
    .overlay.show { display:grid; pointer-events:auto; }
    .overlay .card {
      padding:16px 18px;
      border-radius:14px;
      border:1px solid #ffffff22;
      background: color-mix(in oklab, var(--panel), #000 5%);
      box-shadow:0 8px 26px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
      display:grid; gap:10px; text-align:center;
      min-width: 220px;
    }
    .overlay .title { font-weight:800; }
    .overlay .subtle { color:var(--muted); font-size:12px; }

    .gameover { position:absolute; inset:0; display:none; place-items:center; pointer-events:none; }
    .gameover.show { display:grid; pointer-events:auto; cursor:pointer; }
    .badge { padding:10px 14px; border-radius:999px; border:1px solid #00000022; background:#00000066; backdrop-filter:blur(6px); font-weight:800; color:var(--danger); display:grid; gap:8px; text-align:center; }
    .badge small { color:#fff; font-weight:700; }

    @media (max-width:980px){ .wrap{ grid-template-columns:1fr; gap:10px; padding:8px; width:100vw; max-height:100dvh } .panel{ padding:8px } }
    @media (max-width:420px){ .stat p{ font-size:16px } .stat h3{ font-size:11px } .next-title{ font-size:14px } .row{ gap:8px } }
  </style>
</head>
<body>
  <div class="wrap" id="wrap">
    <div class="panel" id="gamePanel" style="position:relative; margin: 0 auto;">
      <!-- W/H updated here -->
      <canvas id="game" width="400" height="560" aria-label="Suike"></canvas>

      <!-- Start overlay -->
      <div class="overlay" id="startOverlay">
        <div class="card">
          <div class="title" data-i18n="title">Suike</div>
          <div class="subtle" data-i18n="hint">Drag anywhere (except buttons) to aim the top fruit.<br>Release to drop. ← → key to move.</div>
          <button id="startBtn" aria-label="Start" data-i18n="start">Start</button>
        </div>
      </div>

      <!-- Loading / Reset overlay -->
      <div class="overlay" id="loadingOverlay">
        <div class="card">
          <div class="title" data-i18n="resetting">Resetting…</div>
          <div class="subtle" data-i18n="resetTip">Dropping fruits and cleaning the board…</div>
        </div>
      </div>

      <div class="gameover" id="gameover">
        <span class="badge">
          <span data-i18n="gameOver">Game Over</span>
          <small><span data-i18n="scoreLabel">Score</span>: <span id="finalScore">0</span></small>
          <button id="restartOverlay" data-i18n="playAgain">Play Again?</button>
        </span>
      </div>
    </div>

    <aside class="hud panel" id="hudPanel" style="max-width:100%; margin:0 auto;">
      <div class="toolbar">
        <div class="row">
          <button id="restart" style="flex:1;" title="Restart" aria-label="Restart">↻</button>
          <button id="toggleThemeMain" style="flex:1;" title="Toggle theme" aria-label="Toggle theme">◐</button>
        </div>
      </div>

      <div class="score-next">
        <div class="scores">
          <div class="stat">
            <h3 data-i18n="highScore">High Score</h3>
            <p id="highScore">0</p>
          </div>
          <div class="stat">
            <h3 data-i18n="scoreLabel">Score</h3>
            <p id="score">0</p>
          </div>
        </div>

        <div class="next">
          <div class="next-title" data-i18n="next">Next</div>
          <div class="nextCanvasBox">
            <canvas id="nextCanvas" class="fruit-preview"></canvas>
          </div>
        </div>
      </div>

      <p class="hint" id="hintText" data-i18n="hint">Drag anywhere (except buttons) to aim the top fruit.<br>Release to drop. ← → key to move.</p>
    </aside>
  </div>

  <script>
  const I18N_STRINGS = {
    en: {
      title: "Suike",
      start: "Start",
      resetting: "Resetting…",
      resetTip: "Dropping fruits and cleaning the board…",
      gameOver: "Game Over",
      playAgain: "Play Again?",
      highScore: "High Score",
      scoreLabel: "Score",
      next: "Next",
      hint: "Drag anywhere (except buttons) to aim the top fruit.<br>Release to drop. ← → key to move.",
      restartAria: "Restart",
      themeAria: "Toggle theme",
      themeLight: "Switch to light",
      themeDark: "Switch to dark"
    },
    ja: {
      title: "スイケ",
      start: "スタート",
      resetting: "リセット中…",
      resetTip: "フルーツを下に落として盤面をクリアしています…",
      gameOver: "ゲームオーバー",
      playAgain: "もう一度？",
      highScore: "ハイスコア",
      scoreLabel: "スコア",
      next: "次",
      hint: "（ボタン以外の）どこでもドラッグして狙いを定め、<br>離して落とします。← → キーで移動。",
      restartAria: "リスタート",
      themeAria: "テーマを切り替え",
      themeLight: "ライトテーマに切り替え",
      themeDark: "ダークテーマに切り替え"
    },
    zh: {
      title: "Suike",
      start: "开始",
      resetting: "正在重置…",
      resetTip: "让水果掉落清空棋盘…",
      gameOver: "游戏结束",
      playAgain: "再来一局？",
      highScore: "最高分",
      scoreLabel: "分数",
      next: "下一个",
      hint: "在任意位置（按钮除外）拖动以瞄准顶部水果，<br>松开手指投下。按 ← → 键移动。",
      restartAria: "重新开始",
      themeAria: "切换主题",
      themeLight: "切换到浅色主题",
      themeDark: "切换到深色主题"
    },
    ko: {
      title: "Suike",
      start: "시작",
      resetting: "재설정 중…",
      resetTip: "과일을 아래로 떨어뜨려 보드를 비우는 중…",
      gameOver: "게임 오버",
      playAgain: "다시 하시겠습니까?",
      highScore: "최고 점수",
      scoreLabel: "점수",
      next: "다음",
      hint: "어디든(버튼 제외) 드래그하여 위의 과일을 조준하고,<br>놓아서 떨어뜨리세요. ← → 키로 이동합니다.",
      restartAria: "다시 시작",
      themeAria: "테마 전환",
      themeLight: "라이트 테마로 전환",
      themeDark: "다크 테마로 전환"
    }
  };

  function detectLang() {
    const nav = navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language || "en";
    const base = nav.toLowerCase().split("-")[0];
    if (I18N_STRINGS[base]) return base;
    return "en";
  }

  function t(key, lang) {
    const L = I18N_STRINGS[lang] || I18N_STRINGS.en;
    return L[key] ?? I18N_STRINGS.en[key] ?? key;
  }

  function applyI18n(){
    const lang = detectLang();
    document.documentElement.lang = lang;
    document.title = "スイケ " + t("title", lang);

    document.querySelectorAll("[data-i18n]").forEach(el => {
      const key = el.getAttribute("data-i18n");
      if (key === "hint") el.innerHTML = t(key, lang);
      else el.textContent = t(key, lang);
    });

    const restartBtn = document.getElementById("restart");
    const themeBtnMain = document.getElementById("toggleThemeMain");
    if (restartBtn){
      restartBtn.setAttribute("aria-label", t("restartAria", lang));
      restartBtn.setAttribute("title", t("restartAria", lang));
    }
    if (themeBtnMain){
      themeBtnMain.setAttribute("aria-label", t("themeAria", lang));
      themeBtnMain.setAttribute("title", t("themeAria", lang));
    }
  }

  /* ====== Config ====== */
  const W = 400, H = 560, WALL_THICK = 6;  // <-- updated W/H
  const GRAVITY = 1400, RESTITUTION = 0.35, AIR_DAMPING = 0.0008, FRICTION = 0.02;

  const MERGE_TOL_TOUCH = 1.010, MERGE_TOL_COLLIDE_BONUS = 1.015, MERGE_RECENT_COLLIDE_MS = 120, MERGE_COOLDOWN = 220;
  const MAX_FRUIT_INDEX = 9, MAX_DROP_INDEX = 5;
  const DROP_COOLDOWN_MS = 500;
  const WATERMELON_SPECIAL_BONUS = 100;

  const BASE_LARGE = [
    { name:"Cherry", r:28,  color:"#ff5b6e", value:1  },
    { name:"Strawberry", r:40, color:"#7be0d6", value:2  },
    { name:"Grape", r:49, color:"#a067ff", value:3 },
    { name:"Orange", r:57, color:"#ffb347", value:4 },
    { name:"Apple", r:66, color:"#7fd36e", value:5 },
    { name:"Pear", r:80, color:"#b7e071", value:6 },
    { name:"Peach", r:95, color:"#ffa8a0", value:10 },
    { name:"Pineapple", r:110, color:"#ffe066", value:11 },
    { name:"Melon", r:140, color:"#ff7d6b", value:12 },
    { name:"Watermelon", r:180, color:"#41c77f", value:13 },
  ];
  const FRUITS = BASE_LARGE.map(f => ({...f, r: f.r * 1})); // 1:1 size ratio

  const DROP_SCORE_MULT = 1;
  const MERGE_SCORE_MULT = 2;
  const COMBO_MAX_GAP_MS = 1500;
  const COMBO_BONUS_PER_LEVEL = 2;
  const COMBO_WINDOW_MS = 4000;

  /* ====== DOM / State ====== */
  const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score'), highScoreEl = document.getElementById('highScore'), finalScoreEl = document.getElementById('finalScore');
  const gameOverBadge = document.getElementById('gameover');
  const nextCanvas = document.getElementById('nextCanvas'), nextCtx = nextCanvas.getContext('2d');
  const themeBtnMain = document.getElementById('toggleThemeMain'), wrap = document.getElementById('wrap');
  const hudPanel = document.getElementById('hudPanel');
  const gamePanel = document.getElementById('gamePanel');
  const startOverlay = document.getElementById('startOverlay');
  const startBtn = document.getElementById('startBtn');
  const loadingOverlay = document.getElementById('loadingOverlay');

  const HS_KEY = 'suika-highscore';
  let highScore = parseInt(localStorage.getItem(HS_KEY) || '0', 10);
  highScoreEl.textContent = highScore;

  let fruits = [], score = 0, nextTypeIdx = 0;
  let spawn = { x: W/2, y: 40 }, aimX = W/2;
  let holding = true, heldFruit = null, gameOver = false;
  let isDragging = false, activePointerId = null;
  let comboCount = 0, lastMergeTime = 0, lastDropTime = -Infinity;
  let dropCounter = 0;
  let lastMergeDropCounter = -1;

  let floorOpen = false;

  const getVar = n => getComputedStyle(document.documentElement).getPropertyValue(n).trim();
  const boardColors = () => ({ board:getVar('--board-bg')||'#1b2144', wall:getVar('--board-wall')||'#12162e', aim:getVar('--aim')||'#66d9ef88' });
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const now = () => performance.now();
  const MAX_R = Math.max(...FRUITS.map(f=>f.r));

  /* ====== Theme ====== */
  function setTheme(mode){ document.documentElement.dataset.theme = mode; localStorage.setItem('suika-theme', mode||''); document.body.classList.toggle('light-bg', mode==='light'); updateThemeIcon(); }
  function toggleTheme(){ setTheme(document.documentElement.dataset.theme === 'light' ? 'dark' : 'light'); }
  function updateThemeIcon(){
    const lang = document.documentElement.lang || detectLang();
    const isLight = document.documentElement.dataset.theme==='light';
    const symbol = isLight ? '◑':'◐';
    const label = isLight ? t('themeDark', lang) : t('themeLight', lang);
    themeBtnMain.textContent = symbol;
    themeBtnMain.setAttribute('aria-label', t('themeAria', lang));
    themeBtnMain.setAttribute('title', label);
  }

(function () {
  const saved = localStorage.getItem('suika-theme'); // "light" | "dark" | null
  const initial = saved || 'light';                   // default to light on first visit
  setTheme(initial);                                  // setTheme already updates the icon
})();

  (function(){
    applyI18n();
    setTheme(localStorage.getItem('suika-theme')==='light'?'light':'dark');
    updateThemeIcon();
  })();

  const SCORE_PHASES = [
    { max: 200,     w:[60,35,5, 0, 0,0] },
    { max: 500,     w:[55,35,9,1, 0,0] },
    { max: 1000,    w:[50,35,11,3,1,0] },
    { max: 2000,    w:[45,33,14,5,2,1] },
    { max: Infinity,w:[40,28,16,10,4,2] },
  ];
  const pickPhase = s => SCORE_PHASES.find(p => s <= p.max).w;
  function pickWeightedIndex(w){
    let sum=w.reduce((a,b)=>a+b,0), r=Math.random()*sum;
    for (let i=0;i<w.length;i++){ if ((r-=w[i])<=0) return i; }
    return w.length-1;
  }
  function chooseNext(){ nextTypeIdx = Math.min(pickWeightedIndex(pickPhase(score)), MAX_DROP_INDEX); updateNextPreview(); }

  /* ====== Game ====== */
  function resetGame(){
    fruits.length = 0;
    score = 0;
    comboCount = 0;
    lastMergeTime = 0;
    isDragging = false;
    activePointerId = null;
    gameOver = false;
    gameOverBadge.classList.remove('show');
    nextTypeIdx = Math.min(pickWeightedIndex(pickPhase(0)), MAX_DROP_INDEX);
    holding = true;
    heldFruit = createFruit(nextTypeIdx, spawn.x, spawn.y);
    aimX = W/2;
    updateNextPreview();
    scoreEl.textContent = score;
    lastDropTime = -Infinity;
    dropCounter = 0;
    lastMergeDropCounter = -1;
    requestAnimationFrame(adjustCanvasToFit);
  }

  function fancyReset(){
    loadingOverlay.classList.add('show');
    floorOpen = true;
    holding = false;
    heldFruit = null;
    for (const f of fruits){ f.vy = Math.max(f.vy, 400); }

    setTimeout(()=>{
      floorOpen = false;
      resetGame();
      loadingOverlay.classList.remove('show');
    }, 1000);
  }

  function isAnyOverlayActive(){
    return startOverlay.classList.contains('show') || loadingOverlay.classList.contains('show') || gameOverBadge.classList.contains('show');
  }

  function drawFruitBubble(c, cx, cy, r, color){
    const grad = c.createRadialGradient(cx - r*0.4, cy - r*0.4, r*0.3, cx, cy, r);
    grad.addColorStop(0, "#ffffff"); grad.addColorStop(0.02, color); grad.addColorStop(1, shade(color, -20));
    c.fillStyle = grad; c.beginPath(); c.arc(cx, cy, r, 0, Math.PI*2); c.fill();
    c.globalAlpha = .14; c.fillStyle = "#fff"; c.beginPath(); c.ellipse(cx - r*.35, cy - r*.4, r*.55, r*.4, -0.6, 0, Math.PI*2); c.fill(); c.globalAlpha = 1;
    c.lineWidth = Math.max(1, r*.06); c.strokeStyle = "#00000033"; c.stroke();
  }

  function resizeNextCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const rect = nextCanvas.getBoundingClientRect();
    const css = Math.max(60, Math.floor(rect.width || 110));
    const px = Math.floor(css * dpr);
    if (nextCanvas.width !== px) { nextCanvas.width = px; nextCanvas.height = px; updateNextPreview(); }
  }

  function updateNextPreview(){
    const def = FRUITS[nextTypeIdx];
    nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    const PAD = Math.round(nextCanvas.width * 0.07);
    const pearR = FRUITS[5].r;
    const targetMaxR = (nextCanvas.width/2 - PAD) * 0.9;
    const scale = targetMaxR / pearR;
    const r = Math.max(6, def.r * scale);
    drawFruitBubble(nextCtx, nextCanvas.width/2, nextCanvas.height/2, r, def.color);
  }

  function addScore(pts){ score += pts; scoreEl.textContent = score; }

  const floatTexts = [];
  function addFloatText(text, x, y, color="#fff"){ floatTexts.push({text,x,y,color,born:now(),dur:900,vy:-40}); }
  function drawFloatTexts(){
    const t = now();
    for (let i=floatTexts.length-1;i>=0;i--){
      const ft=floatTexts[i], age=(t-ft.born)/ft.dur; if (age>=1){ floatTexts.splice(i,1); continue; }
      ctx.save(); ctx.globalAlpha=1-age; ctx.fillStyle=ft.color; ctx.font="bold 18px system-ui"; ctx.textAlign="center";
      ctx.fillText(ft.text, ft.x, ft.y + ft.vy*age); ctx.restore();
    }
  }

  let fruitIdCounter = 1;
  function createFruit(type,x,y){ const d=FRUITS[type]; return { id:fruitIdCounter++, type, r:d.r, x, y, vx:0, vy:0, mergedAt:-1, lastCollide:-1 }; }

  function canSpawnAt(x,typeIdx){
    const r=FRUITS[typeIdx].r;
    return fruits.every(f => ((x-f.x)**2 + (spawn.y-f.y)**2) >= (r+f.r)**2);
  }

  function dropHeldFruit(){
    if (!holding || gameOver || isAnyOverlayActive()) return;
    const t = performance.now(); if (t - lastDropTime < DROP_COOLDOWN_MS) return;
    if (!canSpawnAt(heldFruit.x, heldFruit.type)) { endGame(); return; }

    fruits.push(heldFruit);
    addScore(Math.round(FRUITS[heldFruit.type].value * DROP_SCORE_MULT));
    dropCounter++;
    lastDropTime = t; holding = false; heldFruit = null;

    chooseNext();
    setTimeout(()=>{ if (gameOver) return; holding = true; heldFruit = createFruit(nextTypeIdx, aimX, spawn.y); }, 150);
  }

  function endGame(){
    gameOver = true; holding = false; heldFruit = null;
    finalScoreEl.textContent = String(score);
    gameOverBadge.classList.add('show');
    setTimeout(() => document.getElementById('restartOverlay')?.focus(), 0);
    if (score > highScore){ highScore = score; localStorage.setItem(HS_KEY, String(highScore)); highScoreEl.textContent = highScore; }
  }

  function clientXToGameX(clientX){
    const rect = canvas.getBoundingClientRect();
    return clamp((clientX - rect.left) * (canvas.width / rect.width), WALL_THICK + 8, W - WALL_THICK - 8);
  }
  const isInteractiveTarget = el => !!el?.closest('button, a, input, select, textarea, [role="button"], [role="link"], [contenteditable], [data-ignore-drag]');

  function beginDrag(e){
    if (!holding || gameOver || isInteractiveTarget(e.target) || isAnyOverlayActive()) return;
    if (typeof e.button==='number' && e.button!==0) return;
    if (e.pointerType==='touch' && e.isPrimary===false) return;
    if (activePointerId!==null) return;

    activePointerId = e.pointerId ?? 'mouse';
    isDragging = true;

    if (e.target === canvas && e.pointerId != null && canvas.setPointerCapture) {
      try { canvas.setPointerCapture(e.pointerId); } catch(_) {}
    }

    document.documentElement.style.touchAction='none';
    aimX = clientXToGameX(e.clientX); if (heldFruit) heldFruit.x = aimX;
    e.preventDefault?.();
  }
  function moveDrag(e){
    if (!isDragging || (e.pointerId ?? 'mouse')!==activePointerId) return;
    aimX = clientXToGameX(e.clientX); if (holding && heldFruit) heldFruit.x = aimX; e.preventDefault?.();
  }
  function endDragCommit(e){
    if (!isDragging || (e.pointerId ?? 'mouse')!==activePointerId) return;
    isDragging=false; activePointerId=null; document.documentElement.style.touchAction='';
    if (e.target === canvas && e.pointerId != null && canvas.releasePointerCapture) {
      try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
    }
    dropHeldFruit(); e.preventDefault?.();
  }
  function cancelDrag(e){
    if ((e.pointerId ?? 'mouse')!==activePointerId) return;
    isDragging=false; activePointerId=null; document.documentElement.style.touchAction='';
    if (e.target === canvas && e.pointerId != null && canvas.releasePointerCapture) {
      try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
    }
    e.preventDefault?.();
  }

  canvas.addEventListener('pointerdown', beginDrag, {passive:false});
  window.addEventListener('pointermove', moveDrag, {passive:false});
  window.addEventListener('pointerup', endDragCommit, {passive:false});
  window.addEventListener('pointercancel', cancelDrag, {passive:false});


  window.addEventListener('keydown', e=>{
    if (e.key==='ArrowLeft'){
      aimX = clamp((heldFruit?heldFruit.x:aimX) - 16, WALL_THICK+8, W-WALL_THICK-8);
      if (holding && heldFruit) heldFruit.x = aimX;
    }
    if (e.key==='ArrowRight'){
      aimX = clamp((heldFruit?heldFruit.x:aimX) + 16, WALL_THICK+8, W-WALL_THICK-8);
      if (holding && heldFruit) heldFruit.x = aimX;
    }
  });

  document.querySelectorAll('button').forEach(b=>b.addEventListener('click', ()=>setTimeout(()=>b.blur(),0)));
  document.getElementById('restart').addEventListener('click', fancyReset);
  document.getElementById('restartOverlay').addEventListener('click', fancyReset);
  gameOverBadge.addEventListener('click', (e) => {
    if (!e.target || e.target.id !== 'restartOverlay') fancyReset();
  });
  themeBtnMain.addEventListener('click', () => {
    toggleTheme();
    updateThemeIcon();
  });

  // Start overlay behavior
  document.getElementById('startBtn').addEventListener('click', () => {
    startOverlay.classList.remove('show');
  });

  const nearFloor = (f,eps=.5)=> (H - WALL_THICK) - (f.y + f.r) <= eps;
  const nearLeft  = (f,eps=.5)=> (f.x - f.r) - WALL_THICK <= eps;
  const nearRight = (f,eps=.5)=> (f.x + f.r) - (W - WALL_THICK) >= -eps;

  function integrate(f, dt){
    f.vy += GRAVITY * dt;
    f.vx *= (1 - AIR_DAMPING * dt * 1000);
    f.vy *= (1 - AIR_DAMPING * dt * 1000);
    f.x += f.vx * dt; f.y += f.vy * dt;

    // Side walls always active
    if (f.x - f.r < WALL_THICK){ f.x = WALL_THICK + f.r; f.vx = -f.vx * RESTITUTION; f.vy *= (1 - FRICTION); }
    else if (f.x + f.r > W - WALL_THICK){ f.x = W - WALL_THICK - f.r; f.vx = -f.vx * RESTITUTION; f.vy *= (1 - FRICTION); }

    // Floor: disabled when floorOpen (reset animation)
    if (!floorOpen){
      if (f.y + f.r > H - WALL_THICK){ f.y = H - WALL_THICK - f.r; f.vy = -f.vy * RESTITUTION; f.vx *= (1 - FRICTION); }
      if (f.y - f.r < WALL_THICK){ f.y = WALL_THICK + f.r; f.vy = Math.abs(f.vy) * RESTITUTION; }
    }
  }

  function resolveFruitCollision(a,b){
    const dx=b.x-a.x, dy=b.y-a.y, dist=Math.hypot(dx,dy), minDist=a.r+b.r; if (dist===0 || dist>=minDist) return false;
    const overlap=minDist-dist, nx=dx/dist, ny=dy/dist, mA=a.r*a.r, mB=b.r*b.r, totalM=mA+mB;
    let ax = -nx * overlap * (mB/totalM), ay = -ny * overlap * (mB/totalM);
    let bx =  nx * overlap * (mA/totalM), by =  ny * overlap * (mA/totalM);

    if (!floorOpen){ // only clamp against floor when not open
      if (nearFloor(a) && ay>0){ bx += -ax; by += -ay; ax=ay=0; }
      if (nearFloor(b) && by>0){ ax += -bx; ay += -by; bx=by=0; }
    }
    if (nearLeft(a) && ax<0){ bx += -ax; ax=0; }
    if (nearRight(a) && ax>0){ bx += -ax; ax=0; }
    if (nearLeft(b) && bx<0){ ax += -bx; bx=0; }
    if (nearRight(b) && bx>0){ ax += -bx; bx=0; }

    a.x+=ax; a.y+=ay; b.x+=bx; b.y+=by;
    if (!floorOpen){
      a.y = Math.min(a.y, H - WALL_THICK - a.r); b.y = Math.min(b.y, H - WALL_THICK - b.r);
    }
    a.x = clamp(a.x, WALL_THICK + a.r, W - WALL_THICK - a.r);
    b.x = clamp(b.x, WALL_THICK + b.r, W - WALL_THICK - b.r);

    const rvx=b.vx-a.vx, rvy=b.vy-a.vy, velAlongNormal=rvx*nx + rvy*ny, e=0.4, invMA=1/mA, invMB=1/mB;
    const j = -(1+e)*velAlongNormal / (invMA+invMB), jx=j*nx, jy=j*ny;
    a.vx -= jx*invMA; a.vy -= jy*invMA; b.vx += jx*invMB; b.vy += jy*invMB;

    const tx=-ny, ty=nx, relTang=rvx*tx + rvy*ty, jt = -relTang*0.25;
    a.vx -= (jt*tx)*invMA; a.vy -= (jt*ty)*invMA; b.vx += (jt*tx)*invMB; b.vy += (jt*ty)*invMB;

    a.lastCollide = b.lastCollide = performance.now();
    return true;
  }

  function tryMerge(a,b){
    if (a.type!==b.type || floorOpen) return false;
    const t=performance.now();
    if (t-a.mergedAt < MERGE_COOLDOWN || t-b.mergedAt < MERGE_COOLDOWN) return false;

    const dx=b.x-a.x, dy=b.y-a.y, dist=Math.hypot(dx,dy), rsum=a.r+b.r;
    const touching = dist <= rsum*MERGE_TOL_TOUCH;
    const recentHit = (t-a.lastCollide < MERGE_RECENT_COLLIDE_MS) || (t-b.lastCollide < MERGE_RECENT_COLLIDE_MS);
    if (!(touching || (recentHit && dist <= rsum*MERGE_TOL_COLLIDE_BONUS))) return false;

    const cx=(a.x+b.x)/2, cy=(a.y+b.y)/2;

    if (a.type===MAX_FRUIT_INDEX && b.type===MAX_FRUIT_INDEX){
      fruits = fruits.filter(f=>f!==a && f!==b); popEffect(cx,cy,FRUITS[MAX_FRUIT_INDEX].color);
      awardMergePoints(Math.round(FRUITS[MAX_FRUIT_INDEX].value*MERGE_SCORE_MULT)+WATERMELON_SPECIAL_BONUS, cx, cy); return true;
    }

    const merged = createFruit(Math.min(a.type+1, MAX_FRUIT_INDEX), cx, cy);
    merged.vx = (a.vx+b.vx)*0.25; merged.vy = (a.vy+b.vy)*0.25; merged.mergedAt = t;

    if (!floorOpen && merged.y + merged.r > H - WALL_THICK){ merged.y = H - WALL_THICK - merged.r - 0.01; if (merged.vy>0) merged.vy=0; }
    merged.x = clamp(merged.x, WALL_THICK+merged.r, W-WALL_THICK-merged.r);

    fruits = fruits.filter(f=>f!==a && f!==b); fruits.push(merged);
    popEffect(merged.x, merged.y, FRUITS[merged.type].color);
    awardMergePoints(Math.round(FRUITS[merged.type].value*MERGE_SCORE_MULT), merged.x, merged.y);
    return true;
  }

  const pops = [];
  function popEffect(x,y,color){ pops.push({x,y,r:6,color,t:performance.now()}); }
  function drawPops(){
    const t=performance.now();
    for (let i=pops.length-1;i>=0;i--){
      const p=pops[i], age=(t-p.t)/400; if (age>=1){ pops.splice(i,1); continue; }
      ctx.globalAlpha = 1-age; ctx.beginPath(); ctx.arc(p.x,p.y,p.r+age*30,0,Math.PI*2);
      ctx.lineWidth=3; ctx.strokeStyle=p.color; ctx.stroke(); ctx.globalAlpha=1;
    }
  }

  function awardMergePoints(base, x, y){
    const t = performance.now();
    const consecutiveDrop = (dropCounter === lastMergeDropCounter + 1);
    const withinTime = (t - lastMergeTime <= COMBO_MAX_GAP_MS);
    const comboWas = comboCount;
    comboCount = (consecutiveDrop || withinTime) ? comboCount + 1 : 1;
    lastMergeTime = t;
    lastMergeDropCounter = dropCounter;
    const bonus = (comboCount > 1) ? (comboCount - 1) * COMBO_BONUS_PER_LEVEL : 0;
    addScore(base + bonus);
    if (comboCount > 1) addFloatText(`x${comboCount} COMBO! +${bonus}`, x, y - 10, "#ffd166");
  }

  function overlapDepth(a,b){ const dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy); return { pen:(a.r+b.r)-d, dist:d }; }
  function liftFruitChain(f,dy,visited){
    if (dy<=0 || visited.has(f)) return; visited.add(f);
    f.y = Math.max(WALL_THICK+f.r, f.y-dy); f.x = clamp(f.x, WALL_THICK+f.r, W-WALL_THICK-f.r);
    for (const g of fruits){ if (g===f) continue; const {pen}=overlapDepth(f,g); if (pen>0) liftFruitChain((f.y<=g.y)?f:g, pen+0.01, visited); }
  }
  function eliminateOverlapsUpward(maxCycles=12){
    for (let c=0;c<maxCycles;c++){
      let worst=0, A=null, B=null;
      for (let i=0;i<fruits.length;i++) for (let j=i+1;j<fruits.length;j++){
        const {pen}=overlapDepth(fruits[i],fruits[j]); if (pen>worst){ worst=pen; A=fruits[i]; B=fruits[j]; }
      }
      if (worst<=0.0001) break;
      const upper = (A.y<=B.y)?A:B; liftFruitChain(upper, worst+0.01, new Set());
      for (const f of fruits){ if (!floorOpen) f.y = Math.min(f.y, H - WALL_THICK - f.r); f.x = clamp(f.x, WALL_THICK+f.r, W-WALL_THICK-f.r); }
    }
  }

  function solveContactsOnce(){
    for (let pass=0; pass<5; pass++){
      for (let i=0;i<fruits.length;i++) for (let j=i+1;j<fruits.length;j++){
        const a=fruits[i], b=fruits[j]; if (!a||!b) continue;
        if (!gameOver && tryMerge(a,b)){ pass=-1; i=fruits.length; break; }
        resolveFruitCollision(a,b);
      }
    }
  }

  function shade(hex, amt){
    const [r,g,b]=hex.replace('#','').match(/.{1,2}/g).map(x=>parseInt(x,16));
    const c=n=>Math.max(0,Math.min(255,n+Math.round(2.55* amt)));
    return `#${c(r).toString(16).padStart(2,'0')}${c(g).toString(16).padStart(2,'0')}${c(b).toString(16).padStart(2,'0')}`;
  }
  function drawFruit(f){
    const d=FRUITS[f.type], grad=ctx.createRadialGradient(f.x-f.r*.4, f.y-f.r*.4, f.r*.3, f.x, f.y, f.r);
    grad.addColorStop(0,"#ffffff"); grad.addColorStop(0.02,d.color); grad.addColorStop(1,shade(d.color,-20));
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(f.x,f.y,f.r,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=.14; ctx.fillStyle="#fff"; ctx.beginPath(); ctx.ellipse(f.x-f.r*.35,f.y-f.r*.4,f.r*.55,f.r*.4,-0.6,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    ctx.lineWidth=2; ctx.strokeStyle="#00000033"; ctx.stroke();
  }
  function drawHeld(){ if (holding && heldFruit) drawFruit(heldFruit); }

  function drawBackground(){
    const {board,wall,aim}=boardColors();
    ctx.fillStyle=board; ctx.fillRect(0,0,W,H);
    ctx.fillStyle=wall; ctx.fillRect(0,0,WALL_THICK,H); ctx.fillRect(W-WALL_THICK,0,WALL_THICK,H); ctx.fillRect(0,H-WALL_THICK,W,WALL_THICK);
    if (holding && !gameOver){ ctx.strokeStyle=aim; ctx.lineWidth=2; ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(aimX,0); ctx.lineTo(aimX,H); ctx.stroke(); ctx.setLineDash([]); }
  }

  function px(n){ return parseFloat(n||0) || 0; }

  function adjustCanvasToFit(){
    if (window.innerWidth > 980){
      canvas.style.removeProperty('width');
      canvas.style.removeProperty('height');
      wrap.style.transform = '';

      fitToScreenDesktop();
      resizeNextCanvas();
      return;
    }

    wrap.style.transform = 'scale(1)';
    const vh = window.innerHeight, vw = window.innerWidth;
    const aspect = canvas.height / canvas.width;

    const wrapStyles = getComputedStyle(wrap);
    const gamePanelStyles = getComputedStyle(gamePanel);

    const wrapPadY = px(wrapStyles.paddingTop) + px(wrapStyles.paddingBottom);
    const gap = px(wrapStyles.gap) || 10;
    const gamePanelPadY = px(gamePanelStyles.paddingTop) + px(gamePanelStyles.paddingBottom);
    const hudHeight = hudPanel.offsetHeight;

    const otherHeight = wrapPadY + gap + gamePanelPadY + hudHeight;
    const maxCanvasDisplayHeight = Math.max(120, vh - otherHeight);

    const wrapPadX = px(wrapStyles.paddingLeft) + px(wrapStyles.paddingRight);
    const gamePanelPadX = px(gamePanelStyles.paddingLeft) + px(gamePanelStyles.paddingRight);
    const availableWidth = Math.max(200, vw - wrapPadX - gamePanelPadX);

    const widthByHeight = Math.floor(maxCanvasDisplayHeight / aspect);
    const targetWidth = Math.min(availableWidth, widthByHeight);

    canvas.style.width = targetWidth + 'px';

    hudPanel.style.width = '';
    hudPanel.style.margin = '0 auto';

    resizeNextCanvas();
  }

  function fitToScreenDesktop(){
    canvas.style.removeProperty('width');
    wrap.style.transform='scale(1)';
    const M=12, rect=wrap.getBoundingClientRect();
    const scale=Math.min(1,(innerWidth-M)/rect.width,(innerHeight-M)/rect.height);
    wrap.style.transform=`scale(${Math.max(0.7,scale)})`;
  }

  function fitToScreen(){
    if (window.innerWidth <= 980){
      adjustCanvasToFit();
    } else {
      fitToScreenDesktop();
      resizeNextCanvas();
    }
  }

  addEventListener('resize', ()=>{ fitToScreen(); });
  addEventListener('orientationchange', ()=>setTimeout(()=>{ fitToScreen(); },100));

  let last = performance.now();
  function tick(){
    const t=performance.now(); let dt=Math.min((t-last)/1000, 1/20); last=t;
    while (dt>0){ const step=Math.min(dt,1/120); for (const f of fruits) integrate(f,step); solveContactsOnce(); eliminateOverlapsUpward(); dt-=step; }
    if (floorOpen){
      for (let i=fruits.length-1;i>=0;i--){
        if (fruits[i].y - fruits[i].r > H + 80) fruits.splice(i,1);
      }
    }
    ctx.clearRect(0,0,W,H); drawBackground(); fruits.slice().sort((a,b)=>a.y-b.y).forEach(drawFruit); drawHeld(); drawPops(); drawFloatTexts();
    requestAnimationFrame(tick);
  }

  document.getElementById('restart').addEventListener('click', fancyReset);
  document.getElementById('restartOverlay').addEventListener('click', fancyReset);
  gameOverBadge.addEventListener('click', (e) => {
    if (!e.target || e.target.id !== 'restartOverlay') fancyReset();
  });

  // Initial state: prepare game and show the Start overlay
  resetGame();
  startOverlay.classList.add('show');

  requestAnimationFrame(tick); fitToScreen(); resizeNextCanvas();
  const nextBox = document.querySelector('.nextCanvasBox');
  if (window.ResizeObserver && nextBox){ new ResizeObserver(resizeNextCanvas).observe(nextBox); }
  </script>
</body>
</html>
