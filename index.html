<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>スイケ Suike</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <style>
    :root {
      --bg: #0f1220; --panel: #171a2b; --accent: #66d9ef; --text: #e9ecf1; --muted: #99a2b2;
      --danger: #ff6b6b; --ok: #9be564; --board-bg: #1b2144; --board-wall: #12162e; --aim: #66d9ef88;
    }
    :root[data-theme="light"] {
      --bg: #f2f5fb; --panel: #ffffff; --accent: #0b74ff; --text: #1d2330; --muted: #6a7280;
      --danger: #d44b4b; --ok: #4caf50; --board-bg: #f4f7ff; --board-wall: #d9dff0; --aim: #0b74ff66;
    }

    * { box-sizing: border-box; }
    html, body { width:100%; height:100dvh; margin:0; overflow:hidden; overscroll-behavior:none; touch-action:pan-x pan-y; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 800px at 70% -10%, #1a1f39 0%, var(--bg) 55%);
      color: var(--text); display:grid; place-items:center;
    }
    body.light-bg { background: radial-gradient(1200px 800px at 70% -10%, #dfe6ff 0%, var(--bg) 55%); }

    .wrap {
      display:grid; grid-template-columns:auto 360px; gap:12px; padding:10px;
      width:min(1100px,100vw); max-height:calc(100dvh - 20px); align-items:start; transform-origin:top center;
    }
    .panel {
      background:var(--panel); border:1px solid #24284233; border-radius:14px; padding:10px;
      box-shadow:0 10px 30px rgba(0,0,0,.15), inset 0 1px 0 rgba(255,255,255,.03);
    }
    .hud { display:grid; gap:10px; position:sticky; top:10px; }
    .row { display:flex; gap:10px; align-items:center; justify-content:space-between; }

    .stat {
      background: color-mix(in oklab, var(--panel), #000 10%);
      border:1px solid #2a305733; border-radius:12px; padding:8px 10px; text-align:center;
    }
    .stat h3 { margin:0; font-size:12px; color:var(--muted); font-weight:600; letter-spacing:.05em; text-transform:uppercase; }
    .stat p { margin:6px 0 0; font-size:18px; font-weight:700; }

    .next { display:grid; justify-items:center; gap:6px; }
    .next-title { font-weight:700; }
    .fruit-preview { border-radius:50%; display:block; border:2px solid #00000014; box-shadow: inset 0 6px 10px #0004, 0 6px 14px #0002; background:transparent; }
    .nextCanvasBox { width: clamp(96px, 28vw, 160px); }
    #nextCanvas { width:100%; height:auto; display:block; }

    .toolbar .row { justify-content:stretch; }
    button {
      appearance:none; border:1px solid #2a305733; color:var(--text);
      background:linear-gradient(color-mix(in oklab, var(--panel), #000 6%), color-mix(in oklab, var(--panel), #000 12%));
      padding:8px 12px; border-radius:10px; font-weight:700; cursor:pointer;
      box-shadow:0 6px 14px rgba(0,0,0,.18), inset 0 1px 0 rgba(255,255,255,.05); line-height:1;
    }
    button:hover { filter:brightness(1.05); }
    button:active { transform:translateY(1px); }
    #toggleThemeMain { width:100%; font-size:18px; }
    .hint { color:var(--muted); font-size:12px; line-height:1.35; }

    .score-next { display:grid; grid-template-columns:1fr auto; gap:12px; align-items:center; }
    .scores { display:grid; gap:10px; }

    #game {
      display:block; background:linear-gradient(#0d0f1b, #0a0c16); border-radius:14px; border:1px solid #24284233;
      box-shadow:0 12px 40px rgba(0,0,0,.25), inset 0 1px rgba(255,255,255,.03);
      width:100%; height:auto; user-select:none; -webkit-user-select:none;
      touch-action:none; /* critical for mobile drag */
    }

    @media (min-width: 981px) {
      .wrap { grid-template-columns:max-content 360px; justify-content:center; }
      .panel:has(#game) { width:max-content; padding:12px; }
      #game { width:500px; }          /* 30% bigger on desktop */
      .nextCanvasBox { width:140px; }
    }

    .gameover { position:absolute; inset:0; display:none; place-items:center; pointer-events:none; }
    .gameover.show { display:grid; pointer-events:auto; cursor:pointer; } /* allow clicks when shown + pointer cursor */
    .badge { padding:10px 14px; border-radius:999px; border:1px solid #00000022; background:#00000066; backdrop-filter:blur(6px); font-weight:800; color:var(--danger); display:grid; gap:8px; text-align:center; }
    .badge small { color:#fff; font-weight:700; }

    @media (max-width:980px){ .wrap{ grid-template-columns:1fr; gap:10px; padding:8px; width:100vw; max-height:100dvh } .hud{ position:static } .panel{ padding:8px } }
    @media (max-width:420px){ .stat p{ font-size:16px } .stat h3{ font-size:11px } .next-title{ font-size:14px } .row{ gap:8px } }
  </style>
</head>
<body>
  <div class="wrap" id="wrap">
    <div class="panel" style="position:relative;">
      <canvas id="game" width="420" height="525" aria-label="Suika-like Game"></canvas>
      <div class="gameover" id="gameover">
        <span class="badge">
          <span>Game Over</span>
          <small>Score: <span id="finalScore">0</span></small>
          <button id="restartOverlay">Play Again?</button>
        </span>
      </div>
    </div>

    <aside class="hud panel">
      <div class="toolbar">
        <div class="row">
          <button id="restart" style="flex:1;">Restart</button>
          <button id="toggleThemeMain" style="flex:1;" title="Toggle theme" aria-label="Toggle theme">◐</button>
        </div>
      </div>

      <div class="score-next">
        <div class="scores">
          <div class="stat">
            <h3>High Score</h3>
            <p id="highScore">0</p>
          </div>
          <div class="stat">
            <h3>Score</h3>
            <p id="score">0</p>
          </div>
        </div>

        <div class="next">
          <div class="next-title">Next</div>
          <div class="nextCanvasBox">
            <canvas id="nextCanvas" class="fruit-preview"></canvas>
          </div>
        </div>
      </div>

      <p class="hint">Drag anywhere (except buttons) to aim the top fruit.<br>Release to drop. ← → key to move.</p>
    </aside>
  </div>

  <script>
  /* ====== Config ====== */
  const W = 420, H = 525, WALL_THICK = 6;
  const GRAVITY = 1400, RESTITUTION = 0.35, AIR_DAMPING = 0.0008, FRICTION = 0.02;

  const MERGE_TOL_TOUCH = 1.010, MERGE_TOL_COLLIDE_BONUS = 1.015, MERGE_RECENT_COLLIDE_MS = 120, MERGE_COOLDOWN = 220;
  const MAX_FRUIT_INDEX = 9, MAX_DROP_INDEX = 5; // Drops capped at Pear
  const DROP_COOLDOWN_MS = 500;
  const WATERMELON_SPECIAL_BONUS = 1000, COMBO_WINDOW_MS = 4000, COMBO_BONUS_PER_LEVEL = 50;

  const BASE_LARGE = [
    { name:"Cherry", r:21,  color:"#ff5b6e", value:5  },
    { name:"Strawberry", r:27, color:"#7be0d6", value:8  },
    { name:"Grape", r:36, color:"#a067ff", value:12 },
    { name:"Orange", r:48, color:"#ffb347", value:18 },
    { name:"Apple", r:60, color:"#7fd36e", value:26 },
    { name:"Pear", r:75, color:"#b7e071", value:36 },
    { name:"Peach", r:93, color:"#ffa8a0", value:50 },
    { name:"Pineapple", r:117, color:"#ffe066", value:70 },
    { name:"Melon", r:147, color:"#ff7d6b", value:95 },
    { name:"Watermelon", r:189, color:"#41c77f", value:130 },
  ];
  const FRUITS = BASE_LARGE.map(f => ({...f, r: f.r * 0.9}));
  const DROP_SCORE_MULT = 1, MERGE_SCORE_MULT = 6;

  /* ====== DOM / State ====== */
  const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score'), highScoreEl = document.getElementById('highScore'), finalScoreEl = document.getElementById('finalScore');
  const gameOverBadge = document.getElementById('gameover');
  const nextCanvas = document.getElementById('nextCanvas'), nextCtx = nextCanvas.getContext('2d');
  const themeBtnMain = document.getElementById('toggleThemeMain'), wrap = document.getElementById('wrap');

  const HS_KEY = 'suika-highscore';
  let highScore = parseInt(localStorage.getItem(HS_KEY) || '0', 10);
  highScoreEl.textContent = highScore;

  let fruits = [], score = 0, nextTypeIdx = 0;
  let spawn = { x: W/2, y: 40 }, aimX = W/2;
  let holding = true, heldFruit = null, gameOver = false;
  let isDragging = false, activePointerId = null;
  let comboCount = 0, lastMergeTime = 0, lastDropTime = -Infinity;

  const getVar = n => getComputedStyle(document.documentElement).getPropertyValue(n).trim();
  const boardColors = () => ({ board:getVar('--board-bg')||'#1b2144', wall:getVar('--board-wall')||'#12162e', aim:getVar('--aim')||'#66d9ef88' });
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const now = () => performance.now();
  const MAX_R = Math.max(...FRUITS.map(f=>f.r));

  /* ====== Theme ====== */
  function setTheme(mode){ document.documentElement.dataset.theme = mode; localStorage.setItem('suika-theme', mode||''); document.body.classList.toggle('light-bg', mode==='light'); updateThemeIcon(); }
  function toggleTheme(){ setTheme(document.documentElement.dataset.theme === 'light' ? 'dark' : 'light'); }
  function updateThemeIcon(){ const isLight = document.documentElement.dataset.theme==='light'; const symbol = isLight ? '◑':'◐'; const label = isLight ? 'Switch to dark':'Switch to light'; themeBtnMain.textContent = symbol; themeBtnMain.setAttribute('aria-label',label); themeBtnMain.setAttribute('title',label); }
  (function(){ setTheme(localStorage.getItem('suika-theme')==='light'?'light':'dark'); updateThemeIcon(); })();

  /* ====== Spawn weights (cap at Pear) ====== */
  const SCORE_PHASES = [
    { max: 200,     w:[42,30,16, 8, 3,1] },
    { max: 600,     w:[30,28,20,12, 7,3] },
    { max: 1200,    w:[20,24,22,16,12,6] },
    { max: 2400,    w:[14,18,22,20,16,10] },
    { max: Infinity,w:[10,14,20,22,18,16] },
  ];
  const pickPhase = s => SCORE_PHASES.find(p => s <= p.max).w;
  function pickWeightedIndex(w){
    let sum=w.reduce((a,b)=>a+b,0), r=Math.random()*sum;
    for (let i=0;i<w.length;i++){ if ((r-=w[i])<=0) return i; }
    return w.length-1;
  }
  function chooseNext(){ nextTypeIdx = Math.min(pickWeightedIndex(pickPhase(score)), MAX_DROP_INDEX); updateNextPreview(); }

  /* ====== Game ====== */
  function resetGame(){
    fruits.length = 0; score = 0; comboCount = 0; lastMergeTime = 0; isDragging = false; activePointerId = null; gameOver = false;
    gameOverBadge.classList.remove('show');
    nextTypeIdx = Math.min(pickWeightedIndex(pickPhase(0)), MAX_DROP_INDEX);
    holding = true; heldFruit = createFruit(nextTypeIdx, spawn.x, spawn.y); aimX = W/2;
    updateNextPreview(); scoreEl.textContent = score; lastDropTime = -Infinity;
  }

  function drawFruitBubble(c, cx, cy, r, color){
    const grad = c.createRadialGradient(cx - r*0.4, cy - r*0.4, r*0.3, cx, cy, r);
    grad.addColorStop(0, "#ffffff"); grad.addColorStop(0.02, color); grad.addColorStop(1, shade(color, -20));
    c.fillStyle = grad; c.beginPath(); c.arc(cx, cy, r, 0, Math.PI*2); c.fill();
    c.globalAlpha = .14; c.fillStyle = "#fff"; c.beginPath(); c.ellipse(cx - r*.35, cy - r*.4, r*.55, r*.4, -0.6, 0, Math.PI*2); c.fill(); c.globalAlpha = 1;
    c.lineWidth = Math.max(1, r*.06); c.strokeStyle = "#00000033"; c.stroke();
  }

  function resizeNextCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const rect = nextCanvas.getBoundingClientRect();
    const css = Math.max(60, Math.floor(rect.width || 110));
    const px = Math.floor(css * dpr);
    if (nextCanvas.width !== px) { nextCanvas.width = px; nextCanvas.height = px; updateNextPreview(); }
  }

  function updateNextPreview(){
    const def = FRUITS[nextTypeIdx];
    nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    const PAD = Math.round(nextCanvas.width * 0.07);
    const r = Math.max(6, def.r * ((nextCanvas.width/2 - PAD) / MAX_R));
    drawFruitBubble(nextCtx, nextCanvas.width/2, nextCanvas.height/2, r, def.color);
  }

  function addScore(pts){ score += pts; scoreEl.textContent = score; }

  const floatTexts = [];
  function addFloatText(text, x, y, color="#fff"){ floatTexts.push({text,x,y,color,born:now(),dur:900,vy:-40}); }
  function drawFloatTexts(){
    const t = now();
    for (let i=floatTexts.length-1;i>=0;i--){
      const ft=floatTexts[i], age=(t-ft.born)/ft.dur; if (age>=1){ floatTexts.splice(i,1); continue; }
      ctx.save(); ctx.globalAlpha=1-age; ctx.fillStyle=ft.color; ctx.font="bold 18px system-ui"; ctx.textAlign="center";
      ctx.fillText(ft.text, ft.x, ft.y + ft.vy*age); ctx.restore();
    }
  }

  let fruitIdCounter = 1;
  function createFruit(type,x,y){ const d=FRUITS[type]; return { id:fruitIdCounter++, type, r:d.r, x, y, vx:0, vy:0, mergedAt:-1, lastCollide:-1 }; }

  function canSpawnAt(x,typeIdx){
    const r=FRUITS[typeIdx].r;
    return fruits.every(f => ((x-f.x)**2 + (spawn.y-f.y)**2) >= (r+f.r)**2);
  }

  function dropHeldFruit(){
    if (!holding || gameOver) return;
    const t = performance.now(); if (t - lastDropTime < DROP_COOLDOWN_MS) return;
    if (!canSpawnAt(heldFruit.x, heldFruit.type)) { endGame(); return; }

    fruits.push(heldFruit);
    addScore(Math.round(FRUITS[heldFruit.type].value * DROP_SCORE_MULT));
    lastDropTime = t; holding = false; heldFruit = null;

    chooseNext();
    setTimeout(()=>{ if (gameOver) return; holding = true; heldFruit = createFruit(nextTypeIdx, aimX, spawn.y); }, 150);
  }

  function endGame(){
    gameOver = true; holding = false; heldFruit = null;
    finalScoreEl.textContent = String(score);
    gameOverBadge.classList.add('show');
    // Focus the overlay button for keyboard users
    setTimeout(() => document.getElementById('restartOverlay')?.focus(), 0);
    if (score > highScore){ highScore = score; localStorage.setItem(HS_KEY, String(highScore)); highScoreEl.textContent = highScore; }
  }

  /* ====== Input (mobile-friendly drag) ====== */
  function clientXToGameX(clientX){
    const rect = canvas.getBoundingClientRect();
    return clamp((clientX - rect.left) * (canvas.width / rect.width), WALL_THICK + 8, W - WALL_THICK - 8);
  }
  const isInteractiveTarget = el => !!el?.closest('button, a, input, select, textarea, [role="button"], [role="link"], [contenteditable], [data-ignore-drag]');

  function beginDrag(e){
    if (!holding || gameOver || isInteractiveTarget(e.target)) return;
    if (typeof e.button==='number' && e.button!==0) return;
    if (e.pointerType==='touch' && e.isPrimary===false) return;
    if (activePointerId!==null) return;

    activePointerId = e.pointerId ?? 'mouse';
    isDragging = true;

    if (e.target === canvas && e.pointerId != null && canvas.setPointerCapture) {
      try { canvas.setPointerCapture(e.pointerId); } catch(_) {}
    }

    document.documentElement.style.touchAction='none';
    aimX = clientXToGameX(e.clientX); if (heldFruit) heldFruit.x = aimX;
    e.preventDefault?.();
  }
  function moveDrag(e){
    if (!isDragging || (e.pointerId ?? 'mouse')!==activePointerId) return;
    aimX = clientXToGameX(e.clientX); if (holding && heldFruit) heldFruit.x = aimX; e.preventDefault?.();
  }
  function endDragCommit(e){
    if (!isDragging || (e.pointerId ?? 'mouse')!==activePointerId) return;
    isDragging=false; activePointerId=null; document.documentElement.style.touchAction='';
    if (e.target === canvas && e.pointerId != null && canvas.releasePointerCapture) {
      try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
    }
    dropHeldFruit(); e.preventDefault?.();
  }
  function cancelDrag(e){
    if ((e.pointerId ?? 'mouse')!==activePointerId) return;
    isDragging=false; activePointerId=null; document.documentElement.style.touchAction='';
    if (e.target === canvas && e.pointerId != null && canvas.releasePointerCapture) {
      try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
    }
    e.preventDefault?.();
  }

  canvas.addEventListener('pointerdown', beginDrag, {passive:false});
  window.addEventListener('pointermove', moveDrag, {passive:false});
  window.addEventListener('pointerup', endDragCommit, {passive:false});
  window.addEventListener('pointercancel', cancelDrag, {passive:false});

  
  window.addEventListener('keydown', e=>{
    if (e.key==='ArrowLeft'){
      aimX = clamp((heldFruit?heldFruit.x:aimX) - 16, WALL_THICK+8, W-WALL_THICK-8);
      if (holding && heldFruit) heldFruit.x = aimX;
    }
    if (e.key==='ArrowRight'){
      aimX = clamp((heldFruit?heldFruit.x:aimX) + 16, WALL_THICK+8, W-WALL_THICK-8);
      if (holding && heldFruit) heldFruit.x = aimX;
    }
  });

  document.querySelectorAll('button').forEach(b=>b.addEventListener('click', ()=>setTimeout(()=>b.blur(),0)));
  document.getElementById('restart').addEventListener('click', resetGame);
  document.getElementById('restartOverlay').addEventListener('click', resetGame);
  // NEW: clicking anywhere on the dark overlay also restarts
  gameOverBadge.addEventListener('click', (e) => {
    if (!e.target || e.target.id !== 'restartOverlay') resetGame();
  });

  /* ====== Physics / Merge ====== */
  const nearFloor = (f,eps=.5)=> (H - WALL_THICK) - (f.y + f.r) <= eps;
  const nearLeft  = (f,eps=.5)=> (f.x - f.r) - WALL_THICK <= eps;
  const nearRight = (f,eps=.5)=> (W - WALL_THICK) - (f.x + f.r) <= eps;

  function integrate(f, dt){
    f.vy += GRAVITY * dt;
    f.vx *= (1 - AIR_DAMPING * dt * 1000);
    f.vy *= (1 - AIR_DAMPING * dt * 1000);
    f.x += f.vx * dt; f.y += f.vy * dt;

    if (f.x - f.r < WALL_THICK){ f.x = WALL_THICK + f.r; f.vx = -f.vx * RESTITUTION; f.vy *= (1 - FRICTION); }
    else if (f.x + f.r > W - WALL_THICK){ f.x = W - WALL_THICK - f.r; f.vx = -f.vx * RESTITUTION; f.vy *= (1 - FRICTION); }
    if (f.y + f.r > H - WALL_THICK){ f.y = H - WALL_THICK - f.r; f.vy = -f.vy * RESTITUTION; f.vx *= (1 - FRICTION); }
    if (f.y - f.r < WALL_THICK){ f.y = WALL_THICK + f.r; f.vy = Math.abs(f.vy) * RESTITUTION; }
  }

  function resolveFruitCollision(a,b){
    const dx=b.x-a.x, dy=b.y-a.y, dist=Math.hypot(dx,dy), minDist=a.r+b.r; if (dist===0 || dist>=minDist) return false;
    const overlap=minDist-dist, nx=dx/dist, ny=dy/dist, mA=a.r*a.r, mB=b.r*b.r, totalM=mA+mB;
    let ax = -nx * overlap * (mB/totalM), ay = -ny * overlap * (mB/totalM);
    let bx =  nx * overlap * (mA/totalM), by =  ny * overlap * (mA/totalM);

    if (nearFloor(a) && ay>0){ bx += -ax; by += -ay; ax=ay=0; }
    if (nearFloor(b) && by>0){ ax += -bx; ay += -by; bx=by=0; }
    if (nearLeft(a) && ax<0){ bx += -ax; ax=0; }
    if (nearRight(a) && ax>0){ bx += -ax; ax=0; }
    if (nearLeft(b) && bx<0){ ax += -bx; bx=0; }
    if (nearRight(b) && bx>0){ ax += -bx; bx=0; }

    a.x+=ax; a.y+=ay; b.x+=bx; b.y+=by;
    a.y = Math.min(a.y, H - WALL_THICK - a.r); b.y = Math.min(b.y, H - WALL_THICK - b.r);
    a.x = clamp(a.x, WALL_THICK + a.r, W - WALL_THICK - a.r);
    b.x = clamp(b.x, WALL_THICK + b.r, W - WALL_THICK - b.r);

    const rvx=b.vx-a.vx, rvy=b.vy-a.vy, velAlongNormal=rvx*nx + rvy*ny, e=0.4, invMA=1/mA, invMB=1/mB;
    const j = -(1+e)*velAlongNormal / (invMA+invMB), jx=j*nx, jy=j*ny;
    a.vx -= jx*invMA; a.vy -= jy*invMA; b.vx += jx*invMB; b.vy += jy*invMB;

    const tx=-ny, ty=nx, relTang=rvx*tx + rvy*ty, jt = -relTang*0.25;
    a.vx -= (jt*tx)*invMA; a.vy -= (jt*ty)*invMA; b.vx += (jt*tx)*invMB; b.vy += (jt*ty)*invMB;

    a.lastCollide = b.lastCollide = performance.now();
    return true;
  }

  function tryMerge(a,b){
    if (a.type!==b.type) return false;
    const t=performance.now();
    if (t-a.mergedAt < MERGE_COOLDOWN || t-b.mergedAt < MERGE_COOLDOWN) return false;

    const dx=b.x-a.x, dy=b.y-a.y, dist=Math.hypot(dx,dy), rsum=a.r+b.r;
    const touching = dist <= rsum*MERGE_TOL_TOUCH;
    const recentHit = (t-a.lastCollide < MERGE_RECENT_COLLIDE_MS) || (t-b.lastCollide < MERGE_RECENT_COLLIDE_MS);
    if (!(touching || (recentHit && dist <= rsum*MERGE_TOL_COLLIDE_BONUS))) return false;

    const cx=(a.x+b.x)/2, cy=(a.y+b.y)/2;

    if (a.type===MAX_FRUIT_INDEX && b.type===MAX_FRUIT_INDEX){
      fruits = fruits.filter(f=>f!==a && f!==b); popEffect(cx,cy,FRUITS[MAX_FRUIT_INDEX].color);
      awardMergePoints(Math.round(FRUITS[MAX_FRUIT_INDEX].value*MERGE_SCORE_MULT)+WATERMELON_SPECIAL_BONUS, cx, cy); return true;
    }

    const merged = createFruit(Math.min(a.type+1, MAX_FRUIT_INDEX), cx, cy);
    merged.vx = (a.vx+b.vx)*0.25; merged.vy = (a.vy+b.vy)*0.25; merged.mergedAt = t;

    if (merged.y + merged.r > H - WALL_THICK){ merged.y = H - WALL_THICK - merged.r - 0.01; if (merged.vy>0) merged.vy=0; }
    merged.x = clamp(merged.x, WALL_THICK+merged.r, W-WALL_THICK-merged.r);

    fruits = fruits.filter(f=>f!==a && f!==b); fruits.push(merged);
    popEffect(merged.x, merged.y, FRUITS[merged.type].color);
    awardMergePoints(Math.round(FRUITS[merged.type].value*MERGE_SCORE_MULT), merged.x, merged.y);
    return true;
  }

  const pops = [];
  function popEffect(x,y,color){ pops.push({x,y,r:6,color,t:performance.now()}); }
  function drawPops(){
    const t=performance.now();
    for (let i=pops.length-1;i>=0;i--){
      const p=pops[i], age=(t-p.t)/400; if (age>=1){ pops.splice(i,1); continue; }
      ctx.globalAlpha = 1-age; ctx.beginPath(); ctx.arc(p.x,p.y,p.r+age*30,0,Math.PI*2);
      ctx.lineWidth=3; ctx.strokeStyle=p.color; ctx.stroke(); ctx.globalAlpha=1;
    }
  }

  function awardMergePoints(base,x,y){
    const t=performance.now(); comboCount = (t-lastMergeTime <= COMBO_WINDOW_MS) ? comboCount+1 : 1; lastMergeTime=t;
    const bonus = (comboCount>1) ? (comboCount-1)*COMBO_BONUS_PER_LEVEL : 0;
    addScore(base + bonus); if (comboCount>1) addFloatText(`x${comboCount} COMBO! +${bonus}`, x, y-10, "#ffd166");
  }

  function overlapDepth(a,b){ const dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy); return { pen:(a.r+b.r)-d, dist:d }; }
  function liftFruitChain(f,dy,visited){
    if (dy<=0 || visited.has(f)) return; visited.add(f);
    f.y = Math.max(WALL_THICK+f.r, f.y-dy); f.x = clamp(f.x, WALL_THICK+f.r, W-WALL_THICK-f.r);
    for (const g of fruits){ if (g===f) continue; const {pen}=overlapDepth(f,g); if (pen>0) liftFruitChain((f.y<=g.y)?f:g, pen+0.01, visited); }
  }
  function eliminateOverlapsUpward(maxCycles=12){
    for (let c=0;c<maxCycles;c++){
      let worst=0, A=null, B=null;
      for (let i=0;i<fruits.length;i++) for (let j=i+1;j<fruits.length;j++){
        const {pen}=overlapDepth(fruits[i],fruits[j]); if (pen>worst){ worst=pen; A=fruits[i]; B=fruits[j]; }
      }
      if (worst<=0.0001) break;
      const upper = (A.y<=B.y)?A:B; liftFruitChain(upper, worst+0.01, new Set());
      for (const f of fruits){ f.y = Math.min(f.y, H - WALL_THICK - f.r); f.x = clamp(f.x, WALL_THICK+f.r, W-WALL_THICK-f.r); }
    }
  }

  function solveContactsOnce(){
    for (let pass=0; pass<5; pass++){
      for (let i=0;i<fruits.length;i++) for (let j=i+1;j<fruits.length;j++){
        const a=fruits[i], b=fruits[j]; if (!a||!b) continue;
        if (!gameOver && tryMerge(a,b)){ pass=-1; i=fruits.length; break; }
        resolveFruitCollision(a,b);
      }
    }
  }

  function shade(hex, amt){
    const [r,g,b]=hex.replace('#','').match(/.{1,2}/g).map(x=>parseInt(x,16));
    const c=n=>Math.max(0,Math.min(255,n+Math.round(2.55*amt)));
    // FIX: padStart for blue channel was missing previously
    return `#${c(r).toString(16).padStart(2,'0')}${c(g).toString(16).padStart(2,'0')}${c(b).toString(16).padStart(2,'0')}`;
  }
  function drawFruit(f){
    const d=FRUITS[f.type], grad=ctx.createRadialGradient(f.x-f.r*.4, f.y-f.r*.4, f.r*.3, f.x, f.y, f.r);
    grad.addColorStop(0,"#ffffff"); grad.addColorStop(0.02,d.color); grad.addColorStop(1,shade(d.color,-20));
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(f.x,f.y,f.r,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=.14; ctx.fillStyle="#fff"; ctx.beginPath(); ctx.ellipse(f.x-f.r*.35,f.y-f.r*.4,f.r*.55,f.r*.4,-0.6,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    ctx.lineWidth=2; ctx.strokeStyle="#00000033"; ctx.stroke();
  }
  function drawHeld(){ if (holding && heldFruit) drawFruit(heldFruit); }

  function drawBackground(){
    const {board,wall,aim}=boardColors();
    ctx.fillStyle=board; ctx.fillRect(0,0,W,H);
    ctx.fillStyle=wall; ctx.fillRect(0,0,WALL_THICK,H); ctx.fillRect(W-WALL_THICK,0,WALL_THICK,H); ctx.fillRect(0,H-WALL_THICK,W,WALL_THICK);
    if (holding && !gameOver){ ctx.strokeStyle=aim; ctx.lineWidth=2; ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(aimX,0); ctx.lineTo(aimX,H); ctx.stroke(); ctx.setLineDash([]); }
  }

  /* ====== Fit & Loop ====== */
  function fitToScreen(){
    wrap.style.transform='scale(1)';
    const M=12, rect=wrap.getBoundingClientRect();
    const scale=Math.min(1,(innerWidth-M)/rect.width,(innerHeight-M)/rect.height);
    wrap.style.transform=`scale(${Math.max(0.7,scale)})`;
  }
  addEventListener('resize', ()=>{ fitToScreen(); resizeNextCanvas(); });
  addEventListener('orientationchange', ()=>setTimeout(()=>{ fitToScreen(); resizeNextCanvas(); },100));

  let last = performance.now();
  function tick(){
    const t=performance.now(); let dt=Math.min((t-last)/1000, 1/20); last=t;
    while (dt>0){ const step=Math.min(dt,1/120); for (const f of fruits) integrate(f,step); solveContactsOnce(); eliminateOverlapsUpward(); dt-=step; }
    ctx.clearRect(0,0,W,H); drawBackground(); fruits.slice().sort((a,b)=>a.y-b.y).forEach(drawFruit); drawHeld(); drawPops(); drawFloatTexts();
    requestAnimationFrame(tick);
  }

  /* ====== Init ====== */
  document.getElementById('restart').addEventListener('click', resetGame);
  document.getElementById('restartOverlay').addEventListener('click', resetGame);
  // Click anywhere on overlay to restart (outside the inner button)
  gameOverBadge.addEventListener('click', (e) => {
    if (!e.target || e.target.id !== 'restartOverlay') resetGame();
  });

  resetGame(); requestAnimationFrame(tick); fitToScreen(); resizeNextCanvas();
  const nextBox = document.querySelector('.nextCanvasBox');
  if (window.ResizeObserver && nextBox){ new ResizeObserver(resizeNextCanvas).observe(nextBox); }
  </script>
</body>
</html>
